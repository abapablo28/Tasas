<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guía Técnica - MonedaValor API</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        h1, h2, h3 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        code {
            background-color: #f6f8fa;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 85%;
        }
        pre {
            background-color: #f6f8fa;
            padding: 16px;
            overflow: auto;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        blockquote {
            margin: 0;
            padding: 0 1em;
            color: #6a737d;
            border-left: 0.25em solid #dfe2e5;
        }
        @media print {
            body { max-width: 100%; padding: 0; }
            pre { white-space: pre-wrap; word-break: break-all; }
        }
    </style>
</head>
<body>

<h1>Guía de Aprendizaje en Profundidad: MonedaValor API</h1>
<p>Este documento explica <strong>línea por línea</strong> y <strong>archivo por archivo</strong> todo el código implementado. El objetivo es que entiendas no solo <em>qué</em> hace el código, sino <em>por qué</em> se escribió así y qué conceptos de Python + FastAPI + Azure hay detrás.</p>

<hr>

<h2>1. El Corazón del Proyecto (<code>requirements.txt</code>)</h2>
<p>Este archivo le dice a Python (y a Azure) qué librerías externas necesitamos.</p>

<pre><code>fastapi==0.115.0      # Framework web moderno y rapidísimo para APIs
uvicorn==0.30.0       # Servidor web (ASGI) que "ejecuta" FastAPI
pyodbc==5.1.0         # Driver estándar para conectar Python con SQL Server / Azure SQL
pydantic-settings     # Manejo robusto de configuración y variables de entorno
python-dotenv         # Lee archivos .env (para desarrollo local)
</code></pre>

<p><strong>Concepto Clave</strong>: Sin este archivo, el código fallaría en la primera línea porque no encontraría <code>fastapi</code> ni <code>pyodbc</code>.</p>

<hr>

<h2>2. Configuración (<code>app/config.py</code>)</h2>
<p>Aquí centralizamos toda la configuración. Si cambia la base de datos o la clave, solo tocamos aquí (o las variables de entorno), nunca el código principal.</p>

<pre><code>from pydantic_settings import BaseSettings  # Clase base para manejar config
from functools import lru_cache             # Para optimizar (cache)

class Settings(BaseSettings):
    """
    Define qué variables necesitamos. Pydantic las busca automáticamente
    en las variables de entorno del sistema o en el archivo .env.
    """
    
    # Variables obligatorias (si faltan, la app no arranca)
    DB_SERVER: str
    DB_NAME: str
    DB_USER: str
    DB_PASSWORD: str
    DB_DRIVER: str = "ODBC Driver 18 for SQL Server"  # Valor por defecto

    API_KEY: str  # La contraseña para que SAP nos hable

    # Metadatos de la API
    APP_TITLE: str = "MonedaValor API"
    APP_VERSION: str = "1.0.0"

    class Config:
        env_file = ".env"          # Busca en .env si existe
        env_file_encoding = "utf-8"

@lru_cache()  # Decorador de optimización
def get_settings() -> Settings:
    """
    Crea la configuración UNA sola vez y la reutiliza.
    Así no leemos el archivo .env 100 veces por segundo.
    """
    return Settings()
</code></pre>

<hr>

<h2>3. Conexión a Base de Datos (<code>app/database.py</code>)</h2>
<p>El puente entre Python y Azure SQL.</p>

<pre><code>import pyodbc
from contextlib import contextmanager  # Herramienta mágica para usar "with"
from .config import get_settings       # Importamos nuestra config

def get_connection_string() -> str:
    """Fabrica el texto largo que pyodbc necesita para conectar."""
    settings = get_settings()
    # f-string: forma moderna de insertar variables en texto
    return (
        f"DRIVER={{{settings.DB_DRIVER}}};"
        f"SERVER={settings.DB_SERVER};"
        f"DATABASE={settings.DB_NAME};"
        f"UID={settings.DB_USER};"
        f"PWD={settings.DB_PASSWORD};"
        f"Encrypt=yes;"                # Azure EXIGE encriptación
        f"TrustServerCertificate=no;"  # Seguridad extra
        f"Connection Timeout=30;"
    )

@contextmanager
def get_db_connection():
    """
    Esto es un Context Manager. Nos permite usar:
    
    with get_db_connection() as conn:
        ...Hacer cosas...
    
    Y cuando termine el bloque 'with', la conexión se cierra AUTOMÁTICAMENTE,
    incluso si hubo un error. ¡Crucial para no tumbar la base de datos!
    """
    conn = pyodbc.connect(get_connection_string())
    try:
        yield conn  # "Presta" la conexión al código que la pidió
    finally:
        conn.close()  # Se asegura de cerrarla siempre
</code></pre>

<hr>

<h2>4. Modelos de Datos (<code>app/models.py</code>)</h2>
<p>Usamos <strong>Pydantic</strong> para definir la forma de nuestros datos. Esto garantiza que la API siempre responda con la estructura correcta (validación automática).</p>

<pre><code>from pydantic import BaseModel
from decimal import Decimal  # Usamos Decimal para dinero, float pierde precisión

class MonedaValor(BaseModel):
    """Define cómo se ve UNA fila de la tabla."""
    id: int
    tipo_moneda: str
    valor: Decimal

class MonedaValorListResponse(BaseModel):
    """
    Define la respuesta completa de la lista.
    Mejor práctica: Envolver la lista en un objeto 'data'
    para poder agregar metadatos (como 'count') en el futuro.
    """
    count: int
    data: list[MonedaValor]  # Lista de objetos MonedaValor
</code></pre>

<hr>

<h2>5. Seguridad (<code>app/auth.py</code>)</h2>
<p>El portero de la discoteca.</p>

<pre><code>from fastapi import Security, HTTPException, status
from fastapi.security import APIKeyHeader
from .config import get_settings

# Le dice a Swagger UI que debe pedir un header llamado "X-API-Key"
api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)

async def verify_api_key(
    api_key: str = Security(api_key_header),  # Inyecta el valor del header
) -> str:
    """
    Esta función se ejecuta ANTES que el endpoint.
    Si la clave está mal, lanza un error 401 y detiene todo.
    """
    if api_key is None:
        raise HTTPException(...)  # Error 401: Falta la clave

    settings = get_settings()
    if api_key != settings.API_KEY:
        raise HTTPException(...)  # Error 401: Clave incorrecta

    return api_key  # Si todo bien, deja pasar
</code></pre>

<hr>

<h2>6. La Aplicación Principal (<code>app/main.py</code>)</h2>
<p>Donde todo se une.</p>

<pre><code>from fastapi import FastAPI, Depends, ...  # Importamos herramientas
from .database import get_db_connection    # Nuestra conexión
from .models import MonedaValor...         # Nuestros modelos
from .auth import verify_api_key           # Nuestro portero

# Inicializamos la app
app = FastAPI(...)

# Configuración CORS (Cross-Origin Resource Sharing)
# Permite que navegadores o apps externas (como un frontend React o SAP)
# hagan peticiones a nuestra API sin ser bloqueados.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Permitir a todo el mundo (en prod podría restringirse)
    ...
)

# --- Endpoint 1: Health Check ---
@app.get("/health")
async def health_check():
    """
    Endpoint público (sin clave) para ver si la API vive.
    Útil para que Azure sepa si reiniciar el servidor.
    """
    ...

# --- Endpoint 2: Listar Monedas ---
@app.get(
    "/api/moneda-valor",
    response_model=MonedaValorListResponse,  # Valida que respondamos bien
)
async def list_moneda_valor(
    # Parámetro opcional (?tipo_moneda=USD)
    tipo_moneda: Optional[str] = Query(None),
    
    # Inyección de dependencia: ¡Aquí llamamos al portero!
    # Si verify_api_key falla, este código NUNCA se ejecuta.
    _api_key: str = Depends(verify_api_key),
):
    try:
        with get_db_connection() as conn:  # Abre conexión
            cursor = conn.cursor()

            # SQL Parametrizado: "?" evita inyección SQL. NUNCA concatenes strings.
            if tipo_moneda:
                cursor.execute(
                    "SELECT ... WHERE TipoMoneda = ?", 
                    (tipo_moneda.strip(),)
                )
            else:
                cursor.execute("SELECT ...")

            rows = cursor.fetchall()

            # Convertimos filas crudas de SQL a nuestros objetos Pydantic
            data = [
                MonedaValor(
                    id=row.Id, 
                    tipo_moneda=row.TipoMoneda.strip(), 
                    valor=row.Valor
                )
                for row in rows
            ]

            return MonedaValorListResponse(count=len(data), data=data)

    except Exception as e:
        # Si algo explota (DB caída), devolvemos 500
        raise HTTPException(status_code=500, detail=str(e))
</code></pre>

<hr>

<h2>7. Despliegue (<code>Dockerfile</code> y <code>startup.sh</code>)</h2>

<h3><code>Dockerfile</code></h3>
<p>Es la receta de cocina para construir el servidor en la nube.</p>
<ol>
<li>Usa Python 3.11 liviano (<code>slim</code>).</li>
<li>Instala herramientas de sistema (<code>curl</code>, <code>gcc</code>) necesarias para compilar drivers.</li>
<li><strong>Instala el driver ODBC de Microsoft</strong> (la parte más difícil, ya resuelta).</li>
<li>Instala las librerías de <code>requirements.txt</code>.</li>
<li>Copia el código y lanza el servidor.</li>
</ol>

<h3><code>startup.sh</code></h3>
<p>Comando que le dice a Azure cómo arrancar en producción.</p>
<pre><code>gunicorn app.main:app ...
</code></pre>
<p>Usa <code>gunicorn</code> (Google Unicorn) como servidor de procesos robusto, que a su vez usa <code>uvicorn</code> (para la velocidad asíncrona). Es la combinación estándar industrial para Python.</p>

</body>
</html>
